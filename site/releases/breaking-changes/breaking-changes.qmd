---
title: "Breaking changes"
date: last-modified
execute:
  echo: false
---

```{r, message=FALSE, warning=FALSE}
# Load necessary libraries
suppressPackageStartupMessages(library(DT))
suppressPackageStartupMessages(library(readr))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(lubridate))  # Suppress messages from lubridate
```

## 2025

```{r, message=FALSE, warning=FALSE}
# Read the 2025 CSV while preserving column names and treating all text as characters
my_data_2025 <- read.csv("2025.csv", check.names = FALSE, stringsAsFactors = FALSE)

# Convert Markdown-style links to proper HTML
my_data_2025[] <- lapply(my_data_2025, function(column) {
  column <- str_replace_all(column, "\\[(.*?)\\]\\((.*?)\\)", "<a href='\\2'>\\1</a>")
  return(column)
})

# Function to format dates properly
format_date <- function(date_column) {
  parsed_dates <- ymd(date_column)
  formatted_dates <- format(parsed_dates, "%b. %d, %Y")
  return(formatted_dates)
}

# Apply date formatting if columns exist
if ("Date announced" %in% names(my_data_2025)) {
  my_data_2025[["Date announced"]] <- format_date(my_data_2025[["Date announced"]])
}
if ("Date of removal" %in% names(my_data_2025)) {
  my_data_2025[["Date of removal"]] <- paste0(
    "<span style='color: #92130cff;'>", format_date(my_data_2025[["Date of removal"]]), "</span>"
  )
}

# Render the interactive, filterable table with a unique ID
datatable(
  my_data_2025, 
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'ftip',
    dom = 'ltip',
    initComplete = JS(
      "function(settings, json) {
        var column = this.api().column(1);
        var select = $('<select><option value=\"\">All product areas</option></select>')
          .appendTo($(column.header()).empty())
          .on('change', function() {
            var val = $.fn.dataTable.util.escapeRegex($(this).val());
            column.search(val ? '^' + val + '$' : '', true, false).draw();
          });
        column.data().unique().sort().each(function(d, j) {
          select.append('<option value=\"'+d+'\">'+d+'</option>')
        });
      }"
    )
  ), 
  escape = FALSE, 
  rownames = FALSE
)
```

## 2024

```{r, message=FALSE, warning=FALSE}
# Read the 2024 CSV while preserving column names and treating all text as characters
my_data_2024 <- read.csv("2024.csv", check.names = FALSE, stringsAsFactors = FALSE)

# Convert Markdown-style links to proper HTML
my_data_2024[] <- lapply(my_data_2024, function(column) {
  column <- str_replace_all(column, "\\[(.*?)\\]\\((.*?)\\)", "<a href='\\2'>\\1</a>")
  return(column)
})

# Apply date formatting if columns exist
if ("Date announced" %in% names(my_data_2024)) {
  my_data_2024[["Date announced"]] <- format_date(my_data_2024[["Date announced"]])
}
if ("Date of removal" %in% names(my_data_2024)) {
  my_data_2024[["Date of removal"]] <- paste0(
    "<span style='color: #92130cff;'>", format_date(my_data_2024[["Date of removal"]]), "</span>"
  )
}

# Render the interactive, filterable table with a unique ID
datatable(
  my_data_2024, 
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'ftip',
    dom = 'ltip',
    initComplete = JS(
      "function(settings, json) {
        var column = this.api().column(1);
        var select = $('<select><option value=\"\">All product areas</option></select>')
          .appendTo($(column.header()).empty())
          .on('change', function() {
            var val = $.fn.dataTable.util.escapeRegex($(this).val());
            column.search(val ? '^' + val + '$' : '', true, false).draw();
          });
        column.data().unique().sort().each(function(d, j) {
          select.append('<option value=\"'+d+'\">'+d+'</option>')
        });
      }"
    )
  ), 
  escape = FALSE, 
  rownames = FALSE
)

```
