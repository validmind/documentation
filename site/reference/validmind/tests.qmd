---
title: "[validmind](/reference/validmind.html).tests"
sidebar: validmind-reference
---

ValidMind Tests Module

- [data_validation](tests/data_validation.qmd)
- [model_validation](tests/model_validation.qmd)
- [prompt_validation](tests/prompt_validation.qmd)

## describe_test[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def describe_test(
    test_id: {'cls': 'ExprName', 'name': 'TestID'} = None,    raw: {'cls': 'ExprName', 'name': 'bool'} = False,    show: {'cls': 'ExprName', 'name': 'bool'} = True):
```

Get or show details about the test This function can be used to see test details including the test name, description, required inputs and default params. It can also be used to get a dictionary of the above information for programmatic use.

**Parameters**

- **test_id** str: The test ID. Defaults to None.
- **raw** bool: If True, returns a dictionary with the test details. Defaults to False.

## list_tags[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def list_tags(
):
```

List unique tags from all test classes.

## list_tasks[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def list_tasks(
):
```

List unique tasks from all test classes.

## list_tasks_and_tags[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def list_tasks_and_tags(
    as_json = False):
```

List all task types and their associated tags, with one row per task type and all tags for a task type in one row.

**Returns**

- A DataFrame with 'Task Type' and concatenated 'Tags'.

## list_tests[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def list_tests(
    filter = None,    task = None,    tags = None,    pretty = True,    truncate = True):
```

List all tests in the tests directory.

**Parameters**

- **filter** str: Find tests where the ID, tasks or tags match the filter string. Defaults to None.
- **task** str: Find tests that match the task. Can be used to narrow down matches from the filter string. Defaults to None.
- **tags** list: Find tests that match list of tags. Can be used to narrow down matches from the filter string. Defaults to None.
- **pretty** bool: If True, returns a pandas DataFrame with a formatted table. Defaults to True.
- **truncate** bool: If True, truncates the test description to the first line. Defaults to True. (only used if pretty=True)

**Returns**

- list or pandas.DataFrame: A list of all tests or a formatted table.

## load_test[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def load_test(
    test_id: {'cls': 'ExprName', 'name': 'str'},    test_func: {'cls': 'ExprName', 'name': 'callable'} = None,    reload: {'cls': 'ExprName', 'name': 'bool'} = False):
```

Load a test by test ID Test IDs are in the format `namespace.path_to_module.TestClassOrFuncName[:tag]`. The tag is optional and is used to distinguish between multiple results from the same test.

**Parameters**

- **test_id** str: The test ID in the format `namespace.path_to_module.TestName[:tag]`
- **test_func** callable: The test function to load. If not provided, the test will be loaded from the test provider. Defaults to None.

## run_test[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def run_test(
    test_id: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'TestID'}, 'None'], 'implicit': True}} = None,    name: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, 'None'], 'implicit': True}} = None,    unit_metrics: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'List'}, 'slice': {'cls': 'ExprName', 'name': 'TestID'}}, 'None'], 'implicit': True}} = None,    inputs: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Dict'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, {'cls': 'ExprName', 'name': 'Any'}], 'implicit': True}}, 'None'], 'implicit': True}} = None,    input_grid: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Dict'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'List'}, 'slice': {'cls': 'ExprName', 'name': 'Any'}}], 'implicit': True}}, {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'List'}, 'slice': {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Dict'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, {'cls': 'ExprName', 'name': 'Any'}], 'implicit': True}}}, 'None'], 'implicit': True}} = None,    params: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Dict'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, {'cls': 'ExprName', 'name': 'Any'}], 'implicit': True}}, 'None'], 'implicit': True}} = None,    param_grid: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Dict'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'List'}, 'slice': {'cls': 'ExprName', 'name': 'Any'}}], 'implicit': True}}, {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'List'}, 'slice': {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Dict'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprName', 'name': 'str'}, {'cls': 'ExprName', 'name': 'Any'}], 'implicit': True}}}, 'None'], 'implicit': True}} = None,    show: {'cls': 'ExprName', 'name': 'bool'} = True,    generate_description: {'cls': 'ExprName', 'name': 'bool'} = True,    title: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Optional'}, 'slice': {'cls': 'ExprName', 'name': 'str'}} = None,    post_process_fn: {'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Union'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprSubscript', 'left': {'cls': 'ExprName', 'name': 'Callable'}, 'slice': {'cls': 'ExprTuple', 'elements': [{'cls': 'ExprList', 'elements': [{'cls': 'ExprName', 'name': 'TestResult'}]}, 'None'], 'implicit': True}}, 'None'], 'implicit': True}} = None,    kwargs = {}) -> {'cls': 'ExprName', 'name': 'TestResult'}:
```

Run a ValidMind or custom test This function is the main entry point for running tests. It can run simple unit metrics, ValidMind and custom tests, composite tests made up of multiple unit metrics and comparison tests made up of multiple tests.

**Parameters**

- **test_id** TestID: Test ID to run. Not required if `name` and `unit_metrics` provided.
- **params** dict: Parameters to customize test behavior. See test details for available parameters.
- **param_grid** Union\[Dict\[str, List[Any]\], List\[Dict[str, Any]\]\]: For comparison tests, either:
- Dict mapping parameter names to lists of values (creates Cartesian product)
- List of parameter dictionaries to test
- **inputs** Dict\[str, Any\]: Test inputs (models/datasets initialized with vm.init_model/dataset)
- **input_grid** Union\[Dict\[str, List[Any]\], List\[Dict[str, Any]\]\]: For comparison tests, either:
- Dict mapping input names to lists of values (creates Cartesian product)
- List of input dictionaries to test
- **name** str: Test name (required for composite metrics)
- **unit_metrics** list: Unit metric IDs to run as composite metric
- **show** bool: Whether to display results. Defaults to True.
- **generate_description** bool: Whether to generate a description. Defaults to True.
- **title** str: Custom title for the test result
- **post_process_fn** Callable\[[TestResult], None\]: Function to post-process the test result

**Returns**

- A TestResult object containing the test results

**Raises**

- **ValueError**: If the test inputs are invalid
- **LoadTestError**: If the test class fails to load

## tags[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def tags(
    tags = ()):
```

Decorator for specifying tags for a test.

**Parameters**

- \***tags**: The tags to apply to the test.

## tasks[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def tasks(
    tasks = ()):
```

Decorator for specifying the task types that a test is designed for.

**Parameters**

- \***tasks**: The task types that the test is designed for.

## test[()]{.muted}

<!-- module.qmd.jinja2 - module level function alias -->

```python
def test(
    func_or_id):
```

Decorator for creating and registering custom tests This decorator registers the function it wraps as a test function within ValidMind under the provided ID. Once decorated, the function can be run using the `validmind.tests.run_test` function.

The function can take two different types of arguments:

- Inputs: ValidMind model or dataset (or list of models/datasets). These arguments must use the following names: `model`, `models`, `dataset`, `datasets`.
- Parameters: Any additional keyword arguments of any type (must have a default value) that can have any name.

The function should return one of the following types:

- Table: Either a list of dictionaries or a pandas DataFrame
- Plot: Either a matplotlib figure or a plotly figure
- Scalar: A single number (int or float)
- Boolean: A single boolean value indicating whether the test passed or failed

The function may also include a docstring. This docstring will be used and logged as the metric's description.

**Parameters**

- **func**: The function to decorate
- **test_id**: The identifier for the metric. If not provided, the function name is used.

**Returns**

- The decorated function.

## register_test_provider[()]{.muted}

<!-- function.qmd.jinja2 - function signature -->

```python
def register_test_provider(
    namespace: str,
    test_provider: TestProvider) -> None:
```

Register an external test provider

**Parameters**

- **namespace** str: The namespace of the test provider
- **test_provider** TestProvider: The test provider

## [class]{.muted} LoadTestError

<!-- class.qmd.jinja2 - class definition -->

```python
class LoadTestError(BaseError):
```

Exception raised when an error occurs while loading a test

**Inherited members**

- **From BaseError**: [class BaseError[()]{.muted}](#class-baseerror), [__init__[()]{.muted}](#__init__), [__str__[()]{.muted}](#__str__), [description[()]{.muted}](#description)
- **From builtins.BaseException**: with_traceback, add_note

## [class]{.muted} LocalTestProvider

<!-- class.qmd.jinja2 - class definition -->

```python
class LocalTestProvider():
```

Test providers in ValidMind are responsible for loading tests from different sources, such as local files, databases, or remote services. The LocalTestProvider specifically loads tests from the local file system.

To use the LocalTestProvider, you need to provide the root_folder, which is the root directory for local tests. The test_id is a combination of the namespace (set when registering the test provider) and the path to the test class module, where slashes are replaced by dots and the .py extension is left out.

Example usage:

```
# Create an instance of LocalTestProvider with the root folder
test_provider = LocalTestProvider("/path/to/tests/folder")

# Register the test provider with a namespace
register_test_provider("my_namespace", test_provider)

# List all tests in the namespace (returns a list of test IDs)
test_provider.list_tests()
# this is used by the validmind.tests.list_tests() function to aggregate all tests
# from all test providers

# Load a test using the test_id (namespace + path to test class module)
test = test_provider.load_test("my_namespace.my_test_class")
# full path to the test class module is /path/to/tests/folder/my_test_class.py
```

**Parameters**

- **root_folder** str: The root directory for local tests.

### [list_tests[()]{.muted}](#list_tests)

<!-- class.qmd.jinja2 - member method signature -->

```python
list_tests(self)
```

List all tests in the given namespace

**Returns**

- A list of test IDs

### [load_test[()]{.muted}](#load_test)

<!-- class.qmd.jinja2 - member method signature -->

```python
load_test(self, test_id)
```

Load the test identified by the given test_id. Args: test_id (str): The identifier of the test. This corresponds to the relative path of the python file from the root folder, with slashes replaced by dots

Returns: The test class that matches the last part of the test_id.

Raises: LocalTestProviderLoadModuleError: If the test module cannot be imported LocalTestProviderLoadTestError: If the test class cannot be found in the module

## [class]{.muted} TestProvider

<!-- class.qmd.jinja2 - class definition -->

```python
class TestProvider(Protocol):
```

Protocol for user-defined test providers

**Inherited members**

### [list_tests[()]{.muted}](#list_tests)

<!-- class.qmd.jinja2 - member method signature -->

```python
list_tests(self)
```

List all tests in the given namespace

**Returns**

- A list of test IDs

### [load_test[()]{.muted}](#load_test)

<!-- class.qmd.jinja2 - member method signature -->

```python
load_test(self, test_id)
```

Load the test function identified by the given test_id

**Parameters**

- **test_id** str: The test ID (does not contain the namespace under which the test is registered)

**Returns**

- The test function

**Raises**

- **FileNotFoundError**: If the test is not found
